public class Solution {
    // https://leetcode.com/problems/4-keys-keyboard/solutions/201902/java-dp-o-n-and-less-generalized-but-more-intuitive-solution/?envType=study-plan-v2&envId=premium-algo-100
    public int MaxA(int N) {
        int[] dp = new int[N+1];
        for (int i=1; i<=N; i++) {
            if (i<=5) {
                // why 5?
                // Select+Copy+Paste requires 3 steps. You will print A,A,Select,Copy,Paste -> and you can get only 4 As. 
                // So for any steps <= 5, the best action is to print A.
                dp[i] = i;
            } else {
                // There are following cases:
                // Type A, which is just dp[i-1]+1
                // Select, copy and paste previous A list generated by three steps before, which is dp[i-3]*2
                // Select, copy, paste, paste. So it is actually pasting dp[i-4] which is the list four steps before and we times three here
                // Select, copy, paste, paste, paste. So it is actually pasting dp[i-5] which is the list five steps before and we times four here
                // We will not have the case of pasting more than 3 times because we can select, copy and paste again to paste with longer A list.
                // Why stop at i-6? because it can be covered by [i-3] in the next iteration.
                dp[i] = Math.Max(dp[i-1]+1, Math.Max(dp[i-3]*2, Math.Max(dp[i-4]*3, dp[i-5]*4)));
            }
        }
        return dp[N];
    }
}